<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>渣博客</title>
  
  <subtitle>渣博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.fangjunhao.com/"/>
  <updated>2019-01-09T13:41:09.970Z</updated>
  <id>http://blog.fangjunhao.com/</id>
  
  <author>
    <name>[object Object]</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap 源码阅读</title>
    <link href="http://blog.fangjunhao.com/2019/01/09/HashMap%20%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://blog.fangjunhao.com/2019/01/09/HashMap 源码阅读/</id>
    <published>2019-01-09T13:34:59.000Z</published>
    <updated>2019-01-09T13:41:09.970Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap-源码阅读"><a href="#HashMap-源码阅读" class="headerlink" title="HashMap 源码阅读"></a>HashMap 源码阅读</h1><p>之前读过一些类的源码，近来发现都忘了，再读一遍整理记录一下。这次读的是 JDK 11 的代码，贴上来的源码会去掉大部分的注释,  也会加上一些自己的理解。</p><p>[TOC]</p><p><img src="https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20181231181859.png" alt=""></p><h2 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h2><p>这里提一下 Map 接口与1.8相比 Map接口又新增了几个方法：<br><img src="https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20190101212411.png" alt=""></p><ul><li>这些方法都是包私有的static方法；</li><li><code>of()</code>方法分别返回包含 0 - 9 个键值对的不可修改的Map；</li><li><code>ofEntries()</code>方法返回包含从给定的<code>entries</code>总提取出来的键值对的不可修改的* Map（不会包含给定的<code>entries</code>）；</li><li><code>entry()</code>方法返回包含键值对的不可修改的 Entry，不允许 null 作为 key 或 value；</li><li><code>copyOf()</code>返回一个不可修改的，包含给定 Map 的 entries 的 Map ，调用了<code>ofEntries()</code>方法.</li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>HashMap 是如何存储键值对的呢?</p><p>HashMap 有一个属性 table:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure></p><p>table 是一个 Node 的数组, 在首次使用和需要 resize 时进行初始化; 这个数组的长度始终是2的幂, 初始化时是0, 因此能够使用位运算来代替模运算.</p><p>HashMap的实现是装箱的(binned, bucketed), 一个 bucket 是 table 数组中的一个元素, 而 bucket 中的元素称为 bin .</p><p>来看一下 Node , 很显然是一个单向链表:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line">    </span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然, 我们都知道 bucket 的结构是会在链表和红黑树之间相互转换的: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换成红黑树</span></span><br><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">    treeifyBin(tab, hash);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换成链表结构</span></span><br><span class="line"><span class="keyword">if</span> (lc &lt;= UNTREEIFY_THRESHOLD)</span><br><span class="line">tab[index] = loHead.untreeify(map);</span><br></pre></td></tr></table></figure><p>注意在 <code>treeifyBin()</code> 方法中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// table 为 null 或者 capacity 小于 MIN_TREEIFY_CAPACITY 会执行 resize() 而不是转换成树结构</span></span><br><span class="line"><span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">    resize();</span><br></pre></td></tr></table></figure></p><p>TreeNode 的结构和 TreeMap 相似, 并且实现了 tree 版本的一些方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">TreeNode&lt;K,V&gt; left;</span><br><span class="line">TreeNode&lt;K,V&gt; right;</span><br><span class="line">TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line"><span class="keyword">boolean</span> red;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="initialCapacity-和-loadFactor"><a href="#initialCapacity-和-loadFactor" class="headerlink" title="initialCapacity 和 loadFactor"></a>initialCapacity 和 loadFactor</h2><p>先看一下 HashMap 的4个构造器，可以发现3个重要的 int ：threshold，initialCapacity 和 loadFactor ，其中 threshold 和 loadFactor 是 HashMap 的私有属性。</p><p>HashMap 的 javadoc 中有相关的解释：</p><ul><li>capacity，HashMap 的哈希表中桶的数量；</li><li>initial capacity ，哈希表创建时桶的数量；</li><li>load factor ，在 capacity 自动增加(<code>resize()</code>)之前，哈希表允许的填满程度；</li><li>threshold，下一次执行<code>resize()</code>时 size 的值 (capacity * load factor), 如果表没有初始化, 存放的是表的长度, 为0时表的长度将会是 <code>DEFAULT_INITIAL_CAPACITY</code> 。</li></ul><p>注意: 构造器中的 initialCapacity 参数并不是 table 的实际长度, 而是期望达到的值, 实际值一般会大于等于给定的值. initialCapacity 会经过<code>tableSizeFor()</code> 方法, 得到一个不大于 MAXIMUM_CAPACITY 的足够大的2的幂, 来作为table的实际长度: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = -<span class="number">1</span> &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadFactor 的默认值是 0.75f ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></p><p>initialCapacity 的默认值是16：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure></p><p>capacity 的最大值是1073741824：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure></p><p>在 new 一个 HasMap 时,应该根据 mapping 数量尽量给出 initialCapacity , 减少表容量自增的次数 . <code>putMapEntries()</code> 方法给出了一种计算 initialCapacity 的方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line"><span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">         (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line"><span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">    threshold = tableSizeFor(t);</span><br></pre></td></tr></table></figure></p><p>这段代码里的 t 就是 capacity .    </p><h2 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash() 方法"></a>hash() 方法</h2><p><code>hash()</code> 是 HashMap 用来计算 key 的 hash 值的方法, 这个方法并不是直接返回 key 的 <code>hashCode()</code> 方法的返回值, 而是将 hashCode 的高位移到低位后 再与原值异或.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 HashMap 用 <code>hash &amp; (table.length-1)</code>代替了 模运算 ,  如果直接使用  <code>hashCode()</code>  的返回值的话, 只有hash code的低位(如果 table.length 是2的n次方, 只有最低的 n - 1 位)会参加运算, 高位即使发生变化也会产生碰撞. 而 <code>hash()</code> 方法把 hashCode 的高位与低位异或, 相当于高位也参加了运算, 能够减少碰撞.</p><p>举个例子:<br>假设 table.length - 1 的 值为 0000 0111, 有两个hash code : 0001 0101 和 0000 0101. 这两个hash code 分别与 table.length - 1 做与运算之后的结果是一样的: 0000 0101; 将这两个hash code 的高位和低位异或之后分别得到:  0001 0100、 0000 0101, 此时再分别与 table.length - 1 做与运算的结果是 0000 0100 和 0000 0101, 不再碰撞了.</p><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p><code>resize()</code> 方法负责初始化或扩容 table. 如果 table 为 null 初始化 table 为 一个长度为 threshold 或 DEFAULT_INITIAL_CAPACITY的表; 否则将 table 的长度加倍, 旧 table 中的元素要么呆在原来的 index 要么以2的幂为偏移量在新 table中移动:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">// 旧 table 的容量已经达到最大, 不扩容, 返回旧表</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将旧容量加倍作为新表容量, 如果新表容量没达到容量最大值, 并且旧容量大于等于默认容量, threshold 加倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 旧的threshold 不为 0 , 旧 threshold 作为新表的容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 旧 threshold 为 0 , 用 DEFAULT_INITIAL_CAPACITY 作为新容量, 用默认值计算新 threshold</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 之前没有计算过新 threshold , 计算 threshold</span></span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">    <span class="comment">// 创建新表数组, 更新表引用</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 将旧表中的元素移动到新表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            <span class="comment">// 遍历旧表</span></span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 帮助 GC</span></span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 这个桶里只有一个元素, 此处用位运算代替了模运算</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 如果这个 bucket 的结构是树, 将这个 bucket 中的元素分为高低两部分((e.hash &amp; bit) == 0 就分在低的部分, bit 是 oldCap), 低的部分留在原位, 高的部分放到 newTab[j + oldCap]; 如果某一部分的元素个数小于 UNTREEIFY_THRESHOLD 将这一部分转换成链表形式, 否则就形成新的树结构</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// 将普通结构的 bucket 中的元素分为高低两部分, 低的部分留在原位, 高的部分放到 newTab[j + oldCap]</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>举个例子解释一下高低两部分的划分: </p><ul><li>扩容前 table.length 是 0000 1000 记为 oldCap , table.length - 1 是 0000 0111 记为 oldN;</li><li>扩容后  table.length 是 0001 0000 记为 newCap,  table.length - 1 为 0000 1111 记为 newN;</li><li>有两个Node,  hash ( <code>hash()</code> 方法得到的值)分别为 0000 1101 和 0000 0101 记为 n1 和 n2;</li></ul><p>在扩容前, n1 和 n2 显然是在一个 bucket 里的, 但在扩容后 n1 &amp; newN 和 n2 &amp; newN 的值分别是 0000 1101 和 0000 0101, 这是需要划分成两部分, 并且把属于高部分的 bin 移动到新的 bucket 里的原因.</p><p>扩容后,  hash 中只会有最低的4位参加 index 的计算, 因此可以用第4位来判断属于高部分还是低部分, 也就可以用 <code>(hash &amp; oldCap) == 0</code> 来作为属于低部分的依据了.</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>查找方法只有 <code>get()</code> 和 <code>getOrDefault()</code> 两个, 都是调用了 <code>getNode()</code>方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Override</span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getOrDefault</span><span class="params">(Object key, V defaultValue)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? defaultValue : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getNode-方法"><a href="#getNode-方法" class="headerlink" title="getNode() 方法"></a>getNode() 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// table 已经被初始化且 table 的长度不为 0 且 对应的 bucket 里有 bin</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 第一个节点的 key 和 给定的 key 相同</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// bucket 中还有下一个 bin</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 是树结构的 bucket, 调用树版本的 getNode 方法</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">// 在普通的链表中查找 key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><p>可以通过<code>entrySet()</code>、<code>keySet()</code>、<code>values()</code>分别获得 <code>EntrySet</code>、<code>KeySet()</code>和<code>Values</code>对象, 他们的迭代器都是<code>HashIterator</code>的子类.</p><h3 id="fast-fail-和-modCount"><a href="#fast-fail-和-modCount" class="headerlink" title="fast-fail 和 modCount"></a>fast-fail 和 modCount</h3><p>HashMap 不是线程安全的, 并且实现了 fast-fail 机制. 当一个迭代器被创建的时候(或者迭代器自身的 remove() 方法被调用), 会记录当前的 modCount 作为期待中的 modCount, 并在操作中先检查当前 modCount 是不是和旧的 modCount 相同, 不同则会抛出<code>ConcurrentModificationException</code>.</p><p>任何结构修改(新增或删除节点)都会改变 modCount 的值.</p><h2 id="新增和更新"><a href="#新增和更新" class="headerlink" title="新增和更新"></a>新增和更新</h2><p>1.8 之前有4个方法和构造器能够往 HashMap 中添加键值对: 以一个Map为参数的构造器、<code>put()</code>、<code>putAll()</code>、<code>putIfAbsent()</code>, </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">putIfAbsent</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他们分别调用了<code>putMapEntries()</code>和<code>putVal()</code>. 这两个方法中有一个参数 evict , 仅当初始化时(构造器中)为 false.</p><h3 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal() 方法"></a>putVal() 方法</h3><p>来看一下<code>putVal()</code> 方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// table 未被初始化或者长度为 0 时, 执行 resize()</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 对应的 bucket 里没有元素, 新建一个普通 Node 放到这个位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 第一个节点的 key 和 给定的 key 相同</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">        <span class="comment">// 树结构, 调用树版本的 putVal, 如果树结构中存在 key, 将会返回相应的 TreeNode, 否则返回 null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 在链表中没有找到 key, 新建一个节点放到链表末尾</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                    <span class="comment">// 当前桶转换成树结构</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// key 相同 break</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">        <span class="comment">// key 在 map 中存在</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 覆盖旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// key 之前在 map 中不存在, 发生了结构变化, modCount 增加 1</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    <span class="comment">// 扩容</span></span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>HashMap 提供了三个回调方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure></p><h3 id="putMapEntries-方法"><a href="#putMapEntries-方法" class="headerlink" title="putMapEntries() 方法"></a>putMapEntries() 方法</h3><p><code>putMapEntries()</code>方法就简单多了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">        <span class="comment">// table 还没有初始化, 计算出 threshold</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">        <span class="comment">// s 超过了 threshold, 扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 调用 putVal() 方法, 将键值对放进 map</span></span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>删除元素有三个方法, 还有 EntrySet 和 KeySet 的 remove 和 clear 方法: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeNode-方法"><a href="#removeNode-方法" class="headerlink" title="removeNode() 方法"></a>removeNode() 方法</h3><p><code>removeNode()</code> 方法有5个参数, 说明一下其中两个:</p><ul><li>matchValue 为 true 时, 只在 value 符合的情况下删除;</li><li>movable 为 false 时,  删除时不移动其他节点, 只给树版本的删除使用.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// table 已经被初始化且 table 的长度不为 0 且 对应的 bucket 里有 bin</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">// 第一个的 key 和给定的 key 相同</span></span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// bucket 中有不止一个 bin</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 树结构, 调用树版本的 getNode</span></span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在普通的 bucket 中查找 node</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="comment">// 找到了 node , 并且符合删除条件</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 树结构, 调用树版本的 removeNode , 如果节点过少, 会转换成链表结构</span></span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">            <span class="comment">// node 是链表的第一个元素</span></span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 不是第一个元素</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            <span class="comment">// 结构变化 modCount + 1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>HashMap 是一个基于哈希表的装箱了的 Map 的实现; 它的数据结构是一个桶的数组, 桶的结构可能是单向链表或者红黑树, 大部分是链表.</li><li>table 的容量是2的幂, 因此可以用更高效的位运算替代模运算.</li><li>HashMap 使用的 hash 值, 并不是 key 的 <code>hashCode()</code>方法所返回的值, 详细还是看上面吧.</li><li>一个普通桶中的 bin 的数量超过 <code>TREEIFY_THRESHOLD</code>, 并且 table 的容量大于 <code>MIN_TREEIFY_CAPACITY</code>, 这个桶会被转换成树结构; 如果 bin 数量大于<code>TREEIFY_THRESHOLD</code> , 但 table 容量小于 <code>MIN_TREEIFY_CAPACITY</code>, 会进行扩容.</li><li>每次扩容新 table 的容量是老 table 的 2 倍.</li><li>扩容时, 会将原来下标为 index 的桶里的 bin 分为高低两个部分, 高的部分放到 <code>newTab[index + oldCap]</code> 上, 低的部分放在原位; 如果某部分的 bin 的个数小于 <code>UNTREEIFY_THRESHOLD</code> 树结构将会转换成链表结构.</li><li>… … (不想写了, 以后再改吧)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;HashMap-源码阅读&quot;&gt;&lt;a href=&quot;#HashMap-源码阅读&quot; class=&quot;headerlink&quot; title=&quot;HashMap 源码阅读&quot;&gt;&lt;/a&gt;HashMap 源码阅读&lt;/h1&gt;&lt;p&gt;之前读过一些类的源码，近来发现都忘了，再读一遍整理记录一下。
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
      <category term="JDK 源码" scheme="http://blog.fangjunhao.com/tags/JDK-%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Jvm内存区域和GC</title>
    <link href="http://blog.fangjunhao.com/2018/06/06/Jvm%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%92%8CGC/"/>
    <id>http://blog.fangjunhao.com/2018/06/06/Jvm内存区域和GC/</id>
    <published>2018-06-06T14:13:21.000Z</published>
    <updated>2019-01-09T13:23:09.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jvm内存区域和GC"><a href="#Jvm内存区域和GC" class="headerlink" title="Jvm内存区域和GC"></a>Jvm内存区域和GC</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><ul><li><strong>程序计数器</strong> 正在执行的字节码指令的地址（native方法时为undefined）</li><li><strong>Java虚拟机栈</strong> 存储栈帧（局部变量表，操作数栈，动态链接，方法出口）OOM，StackOverflowError</li><li><strong>本地方法栈</strong> 与虚拟机栈类似，是native方法的栈</li></ul><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><ul><li><p><strong>Java堆</strong> 存放对象和数组 OOM</p><ul><li><p><strong>新生带</strong></p><ul><li><strong>Eden</strong><ul><li><strong>Survivor</strong> * 2</li></ul></li></ul><ul><li><strong>老年代</strong></li></ul></li></ul></li><li><p><strong>方法区</strong>（永久代）存储已被虚拟机加载的类信息、常量、静态变量 OOM</p></li><li><strong>运行时常量池</strong> 方法区的一部分，编译器生成的字面量和符号引用 OOM</li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>不是运行时数据区的一部分，但是也会产生OOM。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="垃圾检测"><a href="#垃圾检测" class="headerlink" title="垃圾检测"></a>垃圾检测</h3><ul><li><strong>引用计数</strong> 实现简单且高效，但有循环引用的问题， 目前没有虚拟机的实现采用这个算法</li><li><strong>可达性分析</strong> 从GC Roots（虚拟机栈、方法区静态属性、方法区常量、本地方法栈）开始，沿引用链向下搜索，没被引用链连接的对象就是无用对象</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li><strong>强引用</strong> 代码中普遍存在的引用，只要强引用存在，被引用的对象就不会被回收</li><li><strong>软引用</strong> <code>SoftReference</code>，用来描述有用但并非必须的引用，如果一次GC之后内存仍然不足，会把这些对象列入回收范围进行第二次回收</li><li><strong>弱引用</strong> <code>WeakReference</code>，下次GC必定会被回收</li><li><strong>虚引用</strong> <code>PhantomReference</code>，不会对对象的生存时间产生影响，也无法通过虚引用取得对象实例，用于在对象被回收时收到一个通知</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>判断常量池中的对象是否需要回收与对象相似。</p><p>无用类的条件：</p><ul><li><p>该类的所有实例都被回收</p></li><li><p>加载该类的类加载器已被回收</p></li><li><p>对应的Class对象没在任何地方被引用</p></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li><p>标记-清除</p><ul><li>标记需要回收的对象，再统一回收</li><li>效率不高，内存碎片</li></ul></li><li><p>复制</p><ul><li>将内存分为两块，将存活的对象复制到to空间，将from空间统一清除</li><li>实现简单，运行高效，内存利用率低，存活率较高时复制效率低</li><li>新生代分为一个Eden和两个Survivor，默认大小比为8:1，每次只使用一个Survivor，GC时将新生代存活对象放到未使用的Survivor，放不下的晋升老年代（分配担保）</li></ul></li><li><p>标记-整理</p><ul><li>标记后将存活对象朝一边移动，清理掉端边界外的内存</li></ul></li></ul><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>根据对象存活周期的不同，将内存划分为几块。新生代使用复制算法，老年代使用标记整理</p><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>可达性分析必须在一个能确保一致性的快照中进行，因此在GC进行时需要停止用户线程。</p><h4 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h4><p>可达性分析的耗时较久（方法区就可能有几百兆），因此使用了一组OopMap的数据结构，来存储特定位置上对象内什么偏离量上是什么类型的数据，这样在GC扫描时就可以直接获得这些信息。</p><p>但是会使OopMap内容变化的指令很多，如果每条指令都生成对应的OopMap，空间成本会非常高，因此只记录了特定位置的信息，这些位置就称为安全点，线程只有到达安全点才能暂停。</p><p>具有方法调用、循环跳转、异常跳转功能的指令才会产生安全点。</p><ul><li>抢先式中断（几乎没有虚拟机实现使用） GC发生时，中断所有线程，如果有线程不在安全点，恢复线程，让它跑到安全点</li><li>主动式中断 不直接操作线程，而是在安全点检查中断标志，判断是否需要暂停</li></ul><p>安全区域是安全点的扩展，引用关系不会变化的一段代码片段。线程进入安全区域时，标示自己进入了安全区域，要离开时则检查根节点枚举或整个GC过程是否完成，没有则等待到收到可以离开安全区的信号。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ul><li><p>Serial</p><ul><li>新生代单线程收集器</li><li>垃圾回收时只有GC线程在工作</li></ul></li><li><p>ParNew</p><ul><li>Serial的多线程版本，</li><li>垃圾回收时只有多个GC线程在工作</li></ul></li><li><p>Parallel Scavenge</p><ul><li>新生代收集器，</li><li>并行的多线程收集器，</li><li>可控制的吞吐量（吞吐量优先）</li></ul></li><li><p>Serial Old</p><ul><li>Serial的老年代版本</li></ul></li><li><p>Parallel Old</p><ul><li>Parallel Scavenge的老年代版本</li></ul></li><li><p>CMS</p><ul><li>老年代收集器，</li><li>使用标记清除算法，</li><li>追求最短回收停顿时间，</li><li>只在初始标记阶段（只记录GC Roots能关联到的对象）和重新标记阶段（修正并发标记时发生的引用变化，多线程）会STW，</li><li>对CPU资源敏感，并发时占用一定资源，程序变慢，吞吐量变低</li><li>无法清理浮动垃圾，需要预留一定空间在并发收集时供用户线程使用，如果预留空间不够，会临时启用Serial Old重新进行收集</li><li>内存碎片，找不到足够大的连续内存时，提前触发一次Full GC，可以设置在要进行Full GC，进行一次随便整理（或每几次不压缩的Full GC，整理一次碎片）。</li></ul></li><li><p>G1</p><ul><li>新生代和老年代收集器，面向服务端应用的垃圾收集器</li><li>并行并发、分代收集、空间整合、可预测停顿</li><li>将堆分为多个大小相等的独立区域，新老生代不再物理隔离，</li><li>有计划的避免在整个堆做垃圾回收，优先回收价值最大的区域</li><li>追求低停顿可尝试，追求吞吐量无优势</li></ul></li></ul><h2 id="分配和回收策略"><a href="#分配和回收策略" class="headerlink" title="分配和回收策略"></a>分配和回收策略</h2><ul><li>对象优先在Eden分配</li><li>大对象直接进入老年代  避免在Eden和Survivor中复制大量内存</li><li>长期存活对象进入老年代 每经历一次GC，对象的年龄+1，达到一定岁数就晋升老年代</li><li>动态对象年龄判断 Survivor中，相同年龄的所有对象大小总大于Survivor的一半，年龄大于等于该年龄的对象晋升老年代</li><li>空间分配担保 Survivor空间不足，晋升老年代，有老年代空间不足风险；老年代连续空间小于新生代对象总大小或历次晋升平均大小就会进行Full GC</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>忘掉这个方法</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解Java虚拟机》第2版</p><p>《Java虚拟机规范》Java SE 8版</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jvm内存区域和GC&quot;&gt;&lt;a href=&quot;#Jvm内存区域和GC&quot; class=&quot;headerlink&quot; title=&quot;Jvm内存区域和GC&quot;&gt;&lt;/a&gt;Jvm内存区域和GC&lt;/h1&gt;&lt;h2 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
      <category term="GC" scheme="http://blog.fangjunhao.com/tags/GC/"/>
    
      <category term="JVM" scheme="http://blog.fangjunhao.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>装饰模式和Java IO</title>
    <link href="http://blog.fangjunhao.com/2018/05/26/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E5%92%8CJava-IO/"/>
    <id>http://blog.fangjunhao.com/2018/05/26/装饰模式和Java-IO/</id>
    <published>2018-05-26T12:35:09.000Z</published>
    <updated>2019-01-06T13:05:08.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h2><p><strong>修饰模式</strong>（装饰模式），是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就功能而言，修饰模式相比生成子类更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p><p>装饰模式的UML如下所示：</p><p><img src="http://blog.fangjunhao.com/wp-content/uploads/2018/05/bcc335415219df4d08e10cbd72f6f2f2.png" alt=""></p><p>装饰模式中有四个角色：</p><ul><li><p>Component 抽象构件，最基本、最核心、最原始的接口或抽象类</p></li><li><p>ConcreteComponent 具体构件的引用</p></li><li><p>Decorator 装饰角色， 持有对构件的引用</p></li><li><p>ConcreteDecorator 具体装饰角色</p></li></ul><h2 id="Java-IO中的装饰模式"><a href="#Java-IO中的装饰模式" class="headerlink" title="Java IO中的装饰模式"></a>Java IO中的装饰模式</h2><p>Java IO流就是装饰模式的典型应用。</p><p>与装饰模式中角色对应的类如下：</p><ul><li><p>Component：<code>InputStream</code>，<code>OutputStream</code></p></li><li><p>ConcreteComponent： <code>FileInputStream</code>，<code>PipeInputStream</code>，<code>ByteArrayInputStream</code> &#8230;</p></li><li><p>Decorator：<code>FilterInputStream</code>， <code>FilterOutputStream</code></p></li><li><p>ConcreteDecorator：<code>DataInputStream</code>，<code>BufferedInputStream</code>，<code>LineNumberInputStream</code>&#8230;</p></li></ul><p><code>FilterInputStream</code>和<code>FilterOutputStream</code>做的事情很简单，只是持有了一个Stream的引用并做了代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略掉一些方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>来看下<code>BufferedInputStream</code>的代码（当然只是一部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.io;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_BUFFER_SIZE = <span class="number">8192</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> pos;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> markpos = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> marklimit;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(in, DEFAULT_BUFFER_SIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">        <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">            pos = <span class="number">0</span>;            <span class="comment">/* no mark: throw away the buffer */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length)  <span class="comment">/* no room left in buffer */</span></span><br><span class="line">            <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;  <span class="comment">/* can throw away early part of the buffer */</span></span><br><span class="line">                <span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">                System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">                pos = sz;</span><br><span class="line">                markpos = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">                markpos = -<span class="number">1</span>;   <span class="comment">/* buffer got too big, invalidate mark */</span></span><br><span class="line">                pos = <span class="number">0</span>;        <span class="comment">/* drop buffer contents */</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= MAX_BUFFER_SIZE) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Required array size too large"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;            <span class="comment">/* grow buffer */</span></span><br><span class="line">                <span class="keyword">int</span> nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?</span><br><span class="line">                        pos * <span class="number">2</span> : MAX_BUFFER_SIZE;</span><br><span class="line">                <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                    nsz = marklimit;</span><br><span class="line">                <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line">                System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">                <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                buffer = nbuf;</span><br><span class="line">            &#125;</span><br><span class="line">        count = pos;</span><br><span class="line">        <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            count = n + pos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill();</span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        getBufIfOpen(); <span class="comment">// Check for closed stream</span></span><br><span class="line">        <span class="keyword">if</span> ((off | len | (off + len) | (b.length - (off + len))) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> nread = read1(b, off + n, len - n);</span><br><span class="line">            <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (n == <span class="number">0</span>) ? nread : n;</span><br><span class="line">            n += nread;</span><br><span class="line">            <span class="keyword">if</span> (n &gt;= len)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            <span class="comment">// if not closed but no bytes available, return</span></span><br><span class="line">            InputStream input = in;</span><br><span class="line">            <span class="keyword">if</span> (input != <span class="keyword">null</span> &amp;&amp; input.available() &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>BufferedInputStream</code>中有一个byte数组作为缓存，存放从制定的<code>InputStream</code>中读出的字节；</li><li>它的read放回会先查看buf数组中是否还有可读的字节，如果没有就先调用一次<code>fill()</code>方法从指定的stream中读取字节到buf数组中（或者直接去stream中读取足够的字节，再调用<code>fill()</code>方法）；</li><li><code>BufferedInputStream</code>支持mark，<code>fill()</code>方法会在buf中保留markpos到pos的这个区间内（包括markpos，不包括pos）的字节，当然前提是markpos有效；</li><li>当markpos为0，buf数组中没有空间，buf数组的长度小于等于pos并小于 marklimit和MAX_BUFFER_SIZE，buf将被一个长度为 marklimit、MAX_BUFFER_SIZE和 2 * p中较小值的数组代替（原数组中的字节会被拷贝）。</li></ul><h4 id="关于mark的问题"><a href="#关于mark的问题" class="headerlink" title="关于mark的问题"></a>关于mark的问题</h4><p><code>BufferedInputStream</code>的<code>mark()</code>方法是这样的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See the general contract of the &lt;code&gt;mark&lt;/code&gt;</span></span><br><span class="line"><span class="comment"> * method of &lt;code&gt;InputStream&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   readlimit   the maximum limit of bytes that can be read before</span></span><br><span class="line"><span class="comment"> *                      the mark position becomes invalid.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.io.BufferedInputStream#reset()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readlimit)</span> </span>&#123;</span><br><span class="line">    marklimit = readlimit;</span><br><span class="line">    markpos = pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照doc的意思，markpos应该在读取的字节数超过了readlimit的时候就应该失效。</p><p>但是实际上，只有<code>fill</code>方法中的这一段代码让markpos失效了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;</span><br><span class="line">    markpos = -<span class="number">1</span>;   <span class="comment">/* buffer got too big, invalidate mark */</span></span><br><span class="line">    pos = <span class="number">0</span>;        <span class="comment">/* drop buffer contents */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果marklimit小于buf数组长度，markpos是不会失效的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    ByteArrayInputStream in = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">    BufferedInputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">    <span class="comment">//如果制定了size为1，这段代码将会报错</span></span><br><span class="line">    <span class="comment">//BufferedInputStream bin = new BufferedInputStream(in, 1);</span></span><br><span class="line">    bin.mark(<span class="number">1</span>);</span><br><span class="line">    bin.read();</span><br><span class="line">    bin.read();</span><br><span class="line">    bin.reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，之前也有提到，如果markpos为0， buf是有可能扩容的。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>JDK8源码</p><p>《设计模式之禅》第二版</p><p><a href="https://zh.wikipedia.org/wiki/%E4%BF%AE%E9%A5%B0%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener">修饰模式</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;装饰模式&quot;&gt;&lt;a href=&quot;#装饰模式&quot; class=&quot;headerlink&quot; title=&quot;装饰模式&quot;&gt;&lt;/a&gt;装饰模式&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;修饰模式&lt;/strong&gt;（装饰模式），是面向对象编程领域中，一种动态地往一个类中添加新的行为的设计模式。就
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>使用Retrofit2调用HTTP API</title>
    <link href="http://blog.fangjunhao.com/2018/05/25/%E4%BD%BF%E7%94%A8Retrofit2%E8%B0%83%E7%94%A8HTTP-API/"/>
    <id>http://blog.fangjunhao.com/2018/05/25/使用Retrofit2调用HTTP-API/</id>
    <published>2018-05-25T12:25:48.000Z</published>
    <updated>2019-01-06T12:56:40.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Retrofit会将你的HTTP接口调用转换为java的interface,你不必去实现这个接口,交给Retrofit来创建动态代理.</p><p>首先,贴上<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">官网</a>和<a href="http://square.github.io/retrofit/2.x/retrofit/" target="_blank" rel="noopener">Javadoc</a>.</p><h2 id="官网上的例子"><a href="#官网上的例子" class="headerlink" title="官网上的例子"></a>官网上的例子</h2><p>加依赖,下jar包什么的就跳过了,来一个官网例子就知道怎么用了.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">    Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建工厂</span></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建代理对象</span></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用方法获得Call对象</span></span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure><pre><code>此时还没有发送请求去调用HTTP API.Call对象提供了同步和异步两种方式来发送请求:</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//同步,出错时抛出IO或者Runtime异常</span></span><br><span class="line">Response response = call.execute();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//异步</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 成功时的回调</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, Throwable t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//TODO 失败时的回调</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>关于Reponse和Call的细节,可以去看Javadoc.</p><h2 id="注解介绍"><a href="#注解介绍" class="headerlink" title="注解介绍"></a>注解介绍</h2><p>Retrofit的类还是挺少的,这里就介绍些我用过的注解吧.</p><h3 id="请求方式的注解"><a href="#请求方式的注解" class="headerlink" title="请求方式的注解"></a>请求方式的注解</h3><p><code>@GET</code>,<code>@POST</code>,<code>@DELETE</code>,<code>@HEAD</code>,<code>@PUT</code>,<code>@PATCH</code>和<code>@HTTP</code>.除了<code>@HTTP</code>之外都没什么好说的.</p><p><code>@HTTP</code>有三个参数:method,hasBody和path:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HTTP</span>(method = <span class="string">"DELETE"</span>, path = <span class="string">"admin/delete_user"</span>, hasBody = <span class="keyword">true</span>)</span><br><span class="line"><span class="function">Call&lt;Message&gt; <span class="title">deleteUser</span><span class="params">(@Body UserVO vo, @Header(<span class="string">"Apitoken"</span>)</span> ApiToken apiToken</span></span><br><span class="line"><span class="function">        , @<span class="title">Header</span><span class="params">(<span class="string">"X-Forwarded-For"</span>)</span> String forwardedFor)</span>;</span><br></pre></td></tr></table></figure><p>一些蛋疼的DELETE,POST或者PUT API的response会有body,但是<code>@DELETE</code>,<code>@POST</code>,<code>@PUT</code>都不能有body,这时候就要用<code>@HTTP</code>了.</p><h3 id="参数位置的注解"><a href="#参数位置的注解" class="headerlink" title="参数位置的注解"></a>参数位置的注解</h3><p><code>@Header</code>,<code>@Body</code>,<code>@Path</code>,<code>@Query</code>,<code>@QueryMap</code>,<code>@Headers</code></p><p>对应的参数如果不是基本类型包装类的话会自动转换为json,没有记错的话,<code>@Query</code>,<code>@QueryMap</code>不能和<code>@POST</code>,<code>@PUT</code>搭配使用,直接来点例子吧.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"strategy"</span>)</span><br><span class="line">Call&lt;List&lt;Strategy&gt;&gt; getStrategyList(<span class="meta">@Query</span>(<span class="string">"tid"</span>) Long tid,</span><br><span class="line">                                        <span class="meta">@Header</span>(<span class="string">"Apitoken"</span>)ApiToken apiToken,</span><br><span class="line">                                        <span class="meta">@Header</span>(<span class="string">"X-Forwarded-For"</span>) String forwardedFor);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"graph/endpoint_counter"</span>)</span><br><span class="line">Call&lt;List&lt;String&gt;&gt; getCounterOfEndpoint(<span class="meta">@QueryMap</span> Map&lt;String, String&gt; map,</span><br><span class="line">                                        <span class="meta">@Header</span>(<span class="string">"Apitoken"</span>) ApiToken apiToken,</span><br><span class="line">                                        <span class="meta">@Header</span>(<span class="string">"X-Forwarded-For"</span>) String forwardedFor);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要在意这个奇怪的API</span></span><br><span class="line"><span class="meta">@Headers</span>(&#123;<span class="string">"Content-type: application/x-www-form-urlencoded"</span>&#125;)</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"alarm/eventcases"</span>)</span><br><span class="line">Call&lt;List&lt;EventCase&gt;&gt; getEventCasesById(<span class="meta">@Query</span>(<span class="string">"eventid"</span>) String eventId, <span class="meta">@Header</span>(<span class="string">"Apitoken"</span>) ApiToken apiToken,</span><br><span class="line">                                        <span class="meta">@Header</span>(<span class="string">"X-Forwarded-For"</span>) String forwardedFor);</span><br></pre></td></tr></table></figure><h3 id="请求数据格式的注解"><a href="#请求数据格式的注解" class="headerlink" title="请求数据格式的注解"></a>请求数据格式的注解</h3><p>需要注意的是格式和参数的注解是对应的.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FormUrlEncoded</span></span><br><span class="line"><span class="meta">@POST</span>(<span class="string">"user/edit"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateUser</span><span class="params">(@Field(<span class="string">"first_name"</span>)</span> String first, @<span class="title">Field</span><span class="params">(<span class="string">"last_name"</span>)</span> String last)</span>;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Multipart</span></span><br><span class="line"><span class="meta">@PUT</span>(<span class="string">"user/photo"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateUser</span><span class="params">(@Part(<span class="string">"photo"</span>)</span> RequestBody photo, @<span class="title">Part</span><span class="params">(<span class="string">"description"</span>)</span> RequestBody description)</span>;</span><br></pre></td></tr></table></figure><h2 id="转换器"><a href="#转换器" class="headerlink" title="转换器"></a>转换器</h2><p>通过添加不同的依赖来使用不同的转换器:</p><ul><li>Gson: com.squareup.retrofit2:converter-gson</li><li>Jackson: com.squareup.retrofit2:converter-jackson</li><li>Moshi: com.squareup.retrofit2:converter-moshi</li><li>Protobuf: com.squareup.retrofit2:converter-protobuf</li><li>Wire: com.squareup.retrofit2:converter-wire</li><li>Simple XML: com.squareup.retrofit2:converter-simplexml</li><li>Scalars (primitives, boxed, and String): com.squareup.retrofit2:converter-scalars</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Retrofit会将你的HTTP接口调用转换为java的interface,你不必去实现这个接口,交给Retrofit来创建动态代理.&lt;/p
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>WebSphere部署Spring Boot</title>
    <link href="http://blog.fangjunhao.com/2018/05/25/WebSphere%E9%83%A8%E7%BD%B2Spring-Boot/"/>
    <id>http://blog.fangjunhao.com/2018/05/25/WebSphere部署Spring-Boot/</id>
    <published>2018-05-25T12:22:47.000Z</published>
    <updated>2019-01-06T11:58:38.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebSphere-Application-Server-Network-Deployment部署"><a href="#WebSphere-Application-Server-Network-Deployment部署" class="headerlink" title="WebSphere Application Server Network Deployment部署"></a>WebSphere Application Server Network Deployment部署</h1><ul><li>Websphere版本: 8.5.5.12.</li><li>这里只简单做操作步骤介绍, 详细的信息请查看IBM的帮助文档</li><li>在页面上使用CTRL+F来找到要操作的地方.</li></ul><h2 id="1-代码和war包改动"><a href="#1-代码和war包改动" class="headerlink" title="1 代码和war包改动"></a>1 代码和war包改动</h2><p>你需要在你的代码中做两处更改, 否则was将找不到你的Spring应用的初始化类.</p><ol><li>修改你的初始化类, 让它直接实现<code>WebApplicationInitializer</code>;</li><li>在webapp/WEB-INF下添加一个如下内容的web.xml;</li><li>打war包, 删除你的war包中的WEB-INF/lib(记得保存一份, 之后我们会在共享库中添加这些jar).<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"3.0"</span> <span class="attr">metadata-complete</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-服务器和虚拟主机配置"><a href="#2-服务器和虚拟主机配置" class="headerlink" title="2 服务器和虚拟主机配置"></a>2 服务器和虚拟主机配置</h2><p>登陆你的was控制台, 做以下这些操作:</p><ol><li>在服务器中新建一个WebSphere Application Server, 一直下一步即可, 或者你也可以使用已有的服务器;</li><li>配置刚才新建的服务器, 在服务器基础架构-&gt;Java SDK中将1.7的sdk设为缺省;</li><li>在通信-&gt;端口中将WC_defaulthost设置为你想要的端口,</li><li>在环境-&gt;虚拟主机中, 新建或者配置原有的虚拟主机, 添加对应端口的主机别名.</li></ol><h2 id="3-创建和配置共享库"><a href="#3-创建和配置共享库" class="headerlink" title="3 创建和配置共享库"></a>3 创建和配置共享库</h2><p>操作页面: 环境-&gt;共享库</p><ol><li>选择对应的作用域后新建一个共享库;</li><li>配置共享库的类路径, 如: ${WAS_INSTALL_ROOT}/optionalLibraries/gateway/lib/;</li><li>将之前从war中取出的jar把放到你配置的路径下.</li></ol><h2 id="4-创建和配置应用程序"><a href="#4-创建和配置应用程序" class="headerlink" title="4 创建和配置应用程序"></a>4 创建和配置应用程序</h2><p>操作页面: 应用程序-&gt;应用程序类型-&gt;Websphere企业应用程序.</p><h3 id="4-1-安装应用程序"><a href="#4-1-安装应用程序" class="headerlink" title="4.1 安装应用程序"></a>4.1 安装应用程序</h3><p>点击安装, 然后做以下这些操作.</p><ol><li>选择去掉了lib的war报上传;</li><li>选择快速路径, 在第二步中应用你想要部署到的服务器;</li><li>在第三步中选择你配置的虚拟主机;</li><li>在第五步中勾上metadata-complete 属性.</li></ol><h3 id="4-2-配置应用程序"><a href="#4-2-配置应用程序" class="headerlink" title="4.2 配置应用程序"></a>4.2 配置应用程序</h3><p>操作页面: 应用程序-&gt;应用程序类型-&gt;Websphere企业应用程序.</p><p>选择刚才新建的应用程序:</p><ol><li>在引用-&gt;共享库引用中, 选择模块, 点击引用共享库, 选择需要的共享库并应用;</li><li>在详细属性-&gt;类装入和更新检测中, 将类装入顺序改为父类最后, 并应用保存;</li></ol><h2 id="5-启动服务器和应用程序"><a href="#5-启动服务器和应用程序" class="headerlink" title="5 启动服务器和应用程序"></a>5 启动服务器和应用程序</h2><ul><li>在服务器-&gt;所有服务器中启动服务器;</li><li>在应用程序-&gt;所有应用程序中启动应用程序;</li><li>默认情况下, 应用会在服务器启动后自动启动;</li><li>可以在日志诊断中查看日志和装入器.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;WebSphere-Application-Server-Network-Deployment部署&quot;&gt;&lt;a href=&quot;#WebSphere-Application-Server-Network-Deployment部署&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>spring websocket集群问题的简单记录</title>
    <link href="http://blog.fangjunhao.com/2018/04/24/spring-websocket%E9%9B%86%E7%BE%A4%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"/>
    <id>http://blog.fangjunhao.com/2018/04/24/spring-websocket集群问题的简单记录/</id>
    <published>2018-04-24T15:43:47.000Z</published>
    <updated>2019-01-06T12:56:52.973Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近公司里遇到一个问题，在集群中一些websocket的消息丢失了。</p><p>产生问题的原理很简单，发送消息的服务和接收者连接的服务不是同一个服务。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>用中间件（mq, redis etc.）来在服务之间进行通信。</p><p>不直接发送websocket消息，而是将消息放在mq或者redis的list中。</p><p>并在redis中维护连接信息，服务根据连接信息来判断自己是否需要处理消息，或者将消息发给接收者连接的服务。</p><h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>我们的项目中使用的是Spring WebSocket，并且使用了STOMP协议，可以去<a href="https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/websocket.html" target="_blank" rel="noopener">官网</a>查看文档。</p><p>代码示例只做维护连接信息的代码示例，因为其他部分都很容易想到。</p><h4 id="维护连接信息的代码示例"><a href="#维护连接信息的代码示例" class="headerlink" title="维护连接信息的代码示例"></a>维护连接信息的代码示例</h4><p>想要在维护STOMP协议的连接信息，可以查看文档的这一部分<a href="https://docs.spring.io/spring/docs/5.0.0.BUILD-SNAPSHOT/spring-framework-reference/html/websocket.html#websocket-stomp-appplication-context-events" target="_blank" rel="noopener">Listening To ApplicationContext Events and Intercepting Messages</a></p><p>这里的连接信息只要是能够标识出不同的服务就OK。</p><p>一下是监听了订阅事件的Listener的部分代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.fjhdtp.websocket.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.server.ServerHttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.WebSocketHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.server.support.HttpSessionHandshakeInterceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInfoInterceptor</span> <span class="keyword">extends</span> <span class="title">HttpSessionHandshakeInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">beforeHandshake</span><span class="params">(ServerHttpRequest request, ServerHttpResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            WebSocketHandler wsHandler, Map&amp;lt;String, Object&amp;gt; attributes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//握手前，往attributes中增加所需信息</span></span><br><span class="line"></span><br><span class="line">        Object loginBean = ...;<span class="comment">//获取登录的用户信息（或其他信息）</span></span><br><span class="line">        attributes.put(WebSocketConstant.WEBSOKET_LOGINBEAN,loginBean);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.beforeHandshake(request, response, wsHandler, attributes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.fjhdtp.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.messaging.SessionSubscribeEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionSubscribeEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&amp;<span class="title">lt</span></span>;SessionSubscribeEvent&amp;gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"serversideMessageTaskExecutor"</span>)</span><br><span class="line">    <span class="keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IMessageHandler messageHandler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(SessionSubscribeEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//获取订阅的destination</span></span><br><span class="line">          String destination = (String) event.getMessage().getHeaders().get(<span class="string">"simpDestination"</span>);</span><br><span class="line">            <span class="comment">//获取登录信息</span></span><br><span class="line">            Object loginBean = ((Map) event.getMessage().getHeaders().get(<span class="string">"simpSessionAttributes"</span>)).get(WebSocketConstant.WEBSOKET_LOGINBEAN);</span><br><span class="line">            <span class="comment">//TODO 向redis中增加连接信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.fjhdtp.message.listener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.socket.messaging.SessionDisconnectEvent;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionDisconnectEventListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&amp;<span class="title">lt</span></span>;SessionDisconnectEvent&amp;gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(SessionDisconnectEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// stomp连接断开，清除连接信息</span></span><br><span class="line">        <span class="comment">//从attributes中获取登录信息（或其他信息）</span></span><br><span class="line">        Object loginBean = ((Map) event.getMessage().getHeaders().get(<span class="string">"simpSessionAttributes"</span>)).get(WebSocketConstant.WEBSOKET_LOGINBEAN);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从redis中移除连接信息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，有些情况下可能不会正常的触发断开连接的事件（在was下就不会有这个事件），因此还会需要HeartBeat。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近公司里遇到一个问题，在集群中一些websocket的消息丢失了。&lt;/p&gt;
&lt;p&gt;产生问题的原理很简单，发送消息的服务和接收者连接的服务不
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
      <category term="websocket" scheme="http://blog.fangjunhao.com/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>借助jxl将Excel中的数据注入到Bean中</title>
    <link href="http://blog.fangjunhao.com/2017/05/16/%E5%80%9F%E5%8A%A9jxl%E5%B0%86Excel%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B3%A8%E5%85%A5%E5%88%B0Bean%E4%B8%AD/"/>
    <id>http://blog.fangjunhao.com/2017/05/16/借助jxl将Excel中的数据注入到Bean中/</id>
    <published>2017-05-16T04:56:40.000Z</published>
    <updated>2018-11-02T06:16:07.952Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用了Hibernate的项目中需要导入多张表的数据，但是我又不想写多次取出Excle数据放到Bean里的代码，于是写了个ExcleUtils来帮助我做这件事。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>技术上，首先肯定是要借助反射的，然后选择了jxl来操作Excle。</p><p>需要的参数上，Excle文件不能少；好像没有什么方法能够在Excel隐藏地放入对应属性名的信息（就是属性名字不会在Excle中显示出来，如果有方法能够做到，请给我留言，多谢！），于是我会需要按照Excle顺序的属性名称数组；然后我需要在Sheet页的序号以及数据从第几行开始；对于Date类型，可能需要SimpleDateFormat对象来进行转换，如果没有就使用默认的。因此这个方法应该是这样的（并且有一个重载版本）：</p><pre><code>public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getDataList(File excelFile, int sheetindex,            int start, String[] props, Class&amp;lt;T&amp;gt; clazz) throws Exception {    return getDataList(excelFile, sheetindex, start, props, clazz, null);}public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getDataList(File excelFile, int sheetindex,            int start, String[] props, Class&amp;lt;T&amp;gt; clazz, SimpleDateFormat sdf) {    //TODO}`&lt;/pre&gt;## 实现本来想把代码拆开说说自己的思路，想了想还是整块代码贴上然后写注释把（只贴相关部分的），其实都蛮简单的。&lt;pre class=&quot;line-numbers prism-highlight&quot; data-start=&quot;1&quot;&gt;`private static final Map&amp;lt;Class&amp;lt;?&amp;gt;, Class&amp;lt;?&amp;gt;&amp;gt; pwMap = new HashMap&amp;lt;Class&amp;lt;?&amp;gt;, Class&amp;lt;?&amp;gt;&amp;gt;();    static {        pwMap.put(byte.class, Byte.class);        pwMap.put(short.class, Short.class);        pwMap.put(int.class, Integer.class);        pwMap.put(long.class, Long.class);        pwMap.put(float.class, Float.class);        pwMap.put(double.class, Double.class);        pwMap.put(boolean.class, Boolean.class);        pwMap.put(char.class, Character.class);    }    private ExcelUtils() {    }    /**     * &amp;lt;p&amp;gt;     * 从Excel中获取对象列     * &amp;lt;/p&amp;gt;     *      * @param excelFile     *            文件     * @param sheetindex     *            第几个sheet     * @param props     *            属性名（按顺序） （如果有非基本类型需要实现valueOf方法）     * @param clazz     *            类型     * @return     * @throws Exception     *      String[], Class, SimpleDateFormat)     */    public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getDataList(File excelFile, int sheetindex,            int startRow, int startCol, String[] props, Class&amp;lt;T&amp;gt; clazz)            throws Exception {        return getDataList(excelFile, sheetindex, startRow, startCol, props,                clazz, null);    }    /**     *      * @param excelFile     *            Excel文件     * @param sheetindex     * @param start     * @param props     * @param clazz     * @param sdf     * @return     * @throws Exception     */    public static &amp;lt;T&amp;gt; List&amp;lt;T&amp;gt; getDataList(File excelFile, int sheetindex,            int startRow, int startCol, String[] props, Class&amp;lt;T&amp;gt; clazz,            SimpleDateFormat sdf) throws Exception {        Workbook excel = null;        try {            excel = Workbook.getWorkbook(excelFile);            Sheet sheet = excel.getSheet(sheetindex);            int n = sheet.getRows();            List&amp;lt;T&amp;gt; result = new ArrayList&amp;lt;T&amp;gt;(n);            for (int i = startRow; i &amp;lt; n; i++) {                Cell[] row = sheet.getRow(i);                result.add(getRowData(props, row, clazz, sdf, startCol));            }            return result;        } catch (BiffException | IOException e) {            throw new Exception(&quot;读取Excel文件出错！&quot;);        } finally {            excel.close();        }    }    /**     * &amp;lt;p&amp;gt;     * 获取其中一行的数据注入到对象中     * &amp;lt;/p&amp;gt;     *      * @param props     * @param row     * @param clazz     * @return     * @throws Exception     */    public static &amp;lt;T&amp;gt; T getRowData(String[] props, Cell[] row, Class&amp;lt;T&amp;gt; clazz,            int startCol) throws Exception {        return getRowData(props, row, clazz, null, startCol);    }    /**     *      * @param props     * @param row     * @param clazz     * @param sdf     * @return     * @throws Exception     */    public static &amp;lt;T&amp;gt; T getRowData(String[] props, Cell[] row, Class&amp;lt;T&amp;gt; clazz,            SimpleDateFormat sdf, int startCol) throws Exception {        // 属性首字母大写        for (int i = 0; i &amp;lt; props.length; i++) {            if (props[i] == null)                continue;            StringBuilder sb = new StringBuilder(props[i]);            sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));            props[i] = sb.toString();        }        // 实例化一个对象        T result = clazz.newInstance();        for (int i = 0; i &amp;lt; props.length; i++) {            String propName = props[i];            if (propName == null) {                continue;            }            Class&amp;lt;?&amp;gt; type = getPropType(clazz, propName);            // 把getter的返回类型作为参数类型获取setter            Method setter = clazz.getMethod(&quot;set&quot; + propName, type);            String contents = row[i + startCol].getContents();            if (contents != null) {                Object val = string2Type(contents, type, sdf);                // 执行setter                setter.invoke(result, val);            }        }        return result;    }    private static final SimpleDateFormat DEFALUT_SIMPLEDATEF = new SimpleDateFormat(            &quot;yyyy-MM-dd&quot;);    @SuppressWarnings(&quot;unchecked&quot;)    private static &amp;lt;T&amp;gt; T string2Type(String val, Class&amp;lt;T&amp;gt; clazz,            SimpleDateFormat sdf) throws Exception {        Method valueOf = null;        // 对Date和String特殊处理        if (String.class == clazz) {            return (T) val;        }        if (Date.class == clazz) {            return (T) (sdf != null ? sdf.parse(val) : DEFALUT_SIMPLEDATEF                    .parse(val));        }        if (char.class == clazz || Character.class == clazz) {            Character c = val.toCharArray().length &amp;gt; 0 ? val.toCharArray()[0]                    : (Character.class == clazz ? null : (char) 0);            return (T) c;        }        // 对基本类型做处理        Class&amp;lt;?&amp;gt; finalclazz = clazz.isPrimitive() ? pwMap.get(clazz) : clazz;        try {            valueOf = finalclazz.getMethod(&quot;valueOf&quot;, String.class);        } catch (NoSuchMethodException e) {            throw new Exception(&quot;成员类型需要有T valueOf(String)静态方法&quot;);        }        return (T) valueOf.invoke(null, val);    }    private static Class&amp;lt;?&amp;gt; getPropType(Class&amp;lt;?&amp;gt; clazz, String propName)            throws NoSuchMethodException, SecurityException {        Method getter = clazz.getMethod(&quot;get&quot; + propName);        Class&amp;lt;?&amp;gt; type = getter.getReturnType();        return type;    }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;使用了Hibernate的项目中需要导入多张表的数据，但是我又不想写多次取出Excle数据放到Bean里的代码，于是写了个ExcleUtil
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
      <category term="常用的代码" scheme="http://blog.fangjunhao.com/tags/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机 II</title>
    <link href="http://blog.fangjunhao.com/2017/05/11/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-II/"/>
    <id>http://blog.fangjunhao.com/2017/05/11/买卖股票的最佳时机-II/</id>
    <published>2017-05-11T01:01:04.000Z</published>
    <updated>2019-01-06T11:59:28.832Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这是“买卖股票的最佳时机 ”系列的第二题，但是。。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。</p><p>样例</p><p>给出一个数组样例[2,1,2,0,1], 返回 2</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>这。。 把数组里<code>prices[i]-prices[i-1]</code>大于0的加起来就好了啊，还有其他更快的方法吗？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2895 ms</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices: Given an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Maximum profit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = prices.length;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            sum += temp&amp;gt;<span class="number">0</span>?temp:<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这是“买卖股票的最佳时机 ”系列的第二题，但是。。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
      <category term="LintCode" scheme="http://blog.fangjunhao.com/tags/LintCode/"/>
    
      <category term="买卖股票的最佳时机" scheme="http://blog.fangjunhao.com/tags/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>买卖股票的最佳时机</title>
    <link href="http://blog.fangjunhao.com/2017/05/11/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    <id>http://blog.fangjunhao.com/2017/05/11/买卖股票的最佳时机/</id>
    <published>2017-05-11T00:58:36.000Z</published>
    <updated>2019-01-06T12:57:01.168Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>中午在LintCode上看到一系列题目，看起来还蛮有意思的，于是先做了第一道。</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交易(例如,一次买卖股票),设计一个算法来找出最大利润。</p><p>您在真实的面试中是否遇到过这个题？ Yes</p><p>样例</p><p>给出一个数组样例 [3,2,3,1,2], 返回 1</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>很容易想到一个O(n<sup>2</sup>)的方法，求出数组中最大的<code>prices[j] - prices[i]</code>（j &gt; i）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 3872 ms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices: Given an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Maximum profit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &amp;lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &amp;lt; l;j++) &#123;</span><br><span class="line">                max = Math.max(max, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><pre><code>### 动态规划显然上面的方法简单好理解但是不快。其实可以把价格数组中相邻两数之差作为一个新的数组sub，此时可以把问题转换为求最大的子数组和，复杂度就是O(n)了。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1364 ms</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prices: Given an integer array</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: Maximum profit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prices == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> l = prices.length;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &amp;lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temps = prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">            temp += temps;</span><br><span class="line">            max = Math.max(max, temp);</span><br><span class="line">            temp = temp&amp;lt;<span class="number">0</span>?<span class="number">0</span>:temp;</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max, temp);</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;中午在LintCode上看到一系列题目，看起来还蛮有意思的，于是先做了第一道。&lt;/p&gt;
&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; 
      
    
    </summary>
    
    
      <category term="Java" scheme="http://blog.fangjunhao.com/tags/Java/"/>
    
      <category term="LintCode" scheme="http://blog.fangjunhao.com/tags/LintCode/"/>
    
      <category term="买卖股票的最佳时机" scheme="http://blog.fangjunhao.com/tags/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>获取请求页面时所带的参数（只能获取在?之后的）</title>
    <link href="http://blog.fangjunhao.com/2017/04/28/%E8%8E%B7%E5%8F%96%E8%AF%B7%E6%B1%82%E9%A1%B5%E9%9D%A2%E6%97%B6%E6%89%80%E5%B8%A6%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%88%E5%8F%AA%E8%83%BD%E8%8E%B7%E5%8F%96%E5%9C%A8-%E4%B9%8B%E5%90%8E%E7%9A%84%EF%BC%89/"/>
    <id>http://blog.fangjunhao.com/2017/04/28/获取请求页面时所带的参数（只能获取在-之后的）/</id>
    <published>2017-04-28T02:15:28.000Z</published>
    <updated>2018-11-02T06:16:07.953Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>各种东西还是需要记录一下啊，积累下来才能是自己的。最近有需要获取请求页面时url所带的参数（这种参数在get和post下都有可能存在），就记录一下好了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>`</p><p>(function(window){</p><pre><code>var url = location.search;var requests = {};var size = 0;if (url.indexOf(&quot;?&quot;) != -1) {    var str = url.substr(1);    var strs = str.split(&quot;&amp;amp;&quot;);    size = strs.length;    for ( var i = 0; i &amp;lt; size; i++) {        requests[strs[i].split(&quot;=&quot;)[0]] = unescape(strs[i].split(&quot;=&quot;)[1]);    }    }    strs = str = url = undefined;</code></pre><pre><code>    window.requests = {        getParameter : function (name) {                return requests[name];        },        getAllParameters : function () {            return requests;        },        size : function () {            return size;        }};`</code></pre><p>}(window));</p><p></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在window下会增加一个<code>requests</code> 对象，这个对象具有如下方法：</p><ul><li><p><code>getParameter(name)</code> 获取名称为name的参数值</p></li><li><p><code>getAllParameters()</code> 返回所有的参数</p></li><li><p><code>size()</code> 返回参数的个数</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;各种东西还是需要记录一下啊，积累下来才能是自己的。最近有需要获取请求页面时url所带的参数（这种参数在get和post下都有可能存在），就记
      
    
    </summary>
    
    
      <category term="常用的代码" scheme="http://blog.fangjunhao.com/tags/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    
      <category term="JavaScript" scheme="http://blog.fangjunhao.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate缓存机制和对象的三种状态</title>
    <link href="http://blog.fangjunhao.com/2017/04/25/Hibernate%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81/"/>
    <id>http://blog.fangjunhao.com/2017/04/25/Hibernate缓存机制和对象的三种状态/</id>
    <published>2017-04-25T07:37:51.000Z</published>
    <updated>2019-01-06T13:39:39.425Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>说起来挺丢人的，工作也快一年了，还没有好好看过几乎天天接触的Hibernate。昨天在开发的时候又遇到了与对象状态和缓存有关的问题，于是找了两篇博客看了看，解决了问题，简单记录一下。</p><p>然后。。我用wordpress新搭的博客，欢迎访问：<a href="http://blog.fjhdtp.cn/" target="_blank" rel="noopener">http://blog.fjhdtp.cn/</a>；</p><p>教程链接<a href="http://www.jianshu.com/p/56750622cac9" target="_blank" rel="noopener">http://www.jianshu.com/p/56750622cac9</a>。</p><h2 id="Hibernate的两层缓存机制"><a href="#Hibernate的两层缓存机制" class="headerlink" title="Hibernate的两层缓存机制"></a>Hibernate的两层缓存机制</h2><p>Hibernate有两层缓存机制，第一级是Session的缓存，第二级是SessionFactory的缓存。</p><p>Session的缓存不能被卸载，并且是事务范围的缓存（通常一个Session对应一个事务），这也是为什么懒加载需要在session关闭之前（session绑定在ThreadLocal）。</p><p>SessionFactory对象的生命周期和应用程序的过程相对应，因此SessionFactory的缓存是进程或集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。</p><h3 id="Hibernate执行查找的过程"><a href="#Hibernate执行查找的过程" class="headerlink" title="Hibernate执行查找的过程"></a>Hibernate执行查找的过程</h3><p>当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；</p><p>查不到，如果配置了二级缓存，那么从二级缓存中查；</p><p>如果都查不到，再查询数据库，把结果按照ID放入到缓存删除、更新、增加数据的时候，同时更新缓存。</p><h2 id="Hibernate对象的三种状态"><a href="#Hibernate对象的三种状态" class="headerlink" title="Hibernate对象的三种状态"></a>Hibernate对象的三种状态</h2><p>Hibernate的对象有三种状态：transient（临时）、persistent（持久）、detached（脱管）。</p><ul><li><em>临时态（transient）</em>  临时态的对象没有被Hibernate的缓存所管理，并且在数据库中没有与之相对应的数据。</li><li><em>持久态（persistent）</em> 持久态的对象被Hibernate的缓存所管理，并且在数据库中有与之对应的数据。</li><li><em>脱管态（detached）</em> 脱管态的对象脱离了Hibernate的缓存管理，并且在数据库中有与之对应的数据。</li></ul><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>我有一个Table A， 我从前台获取一些数据，放入对象b中， 如果A中有对应的数据， 则<code>update()</code>，如果没有则<code>save()</code>。结果我在程序中获得了持久态的对象a（当然a、b都是同一个类的对象）后，试图将a的OID赋值给b，然后<code>update()</code>脱管态的b，结果就报错了。</p><p>之后我试图使用<code>merge()</code>来解决这个问题，结果每次都会新增一条数据。</p><p>稍稍研究了下，只要把临时态对象的数据拷贝到持久态对象中，然后保存持久态对象就可以了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.cnblogs.com/wean/archive/2012/05/16/2502724.html" target="_blank" rel="noopener">Hibernate 缓存机制</a></p><p><a href="http://www.cnblogs.com/greatfish/p/6034448.html" target="_blank" rel="noopener">Hibernate中对象的三个状态解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;说起来挺丢人的，工作也快一年了，还没有好好看过几乎天天接触的Hibernate。昨天在开发的时候又遇到了与对象状态
      
    
    </summary>
    
    
      <category term="Hibernate" scheme="http://blog.fangjunhao.com/tags/Hibernate/"/>
    
  </entry>
  
</feed>

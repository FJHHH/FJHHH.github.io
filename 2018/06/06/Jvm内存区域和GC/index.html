<!DOCTYPE html><html lang="zh-cn"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><title>Jvm内存区域和GC | 渣博客</title><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="author" content="[object Object]"><meta name="designer" content="minfive"><meta name="keywords" content="null"><meta name="description" content="一个学渣的渣博客"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=yes"><meta name="mobile-web-app-capable" content="yes"><meta name="robots" content="all"><link rel="canonical" href="http://blog.fangjunhao.com/2018/06/06/Jvm内存区域和GC/index.html"><link rel="icon" type="image/png" href="undefined" sizes="32x32"><link rel="stylesheet" href="/scss/base/index.css"><link rel="alternate" href="/atom.xml" title="渣博客"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-128550327-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-128550327-1")</script><link rel="stylesheet" href="/scss/views/page/post.css"></head><body ontouchstart=""><div id="page-loading" class="page page-loading" style="background-image:url(undefined)"></div><div id="page" class="page js-hidden"><header class="page__small-header page__header--small"><nav class="page__navbar"><div class="page__container navbar-container"><a class="page__logo" href="/" title="渣博客" alt="渣博客"><img src="/img/logo.png" alt="渣博客"></a><nav class="page__nav"><ul class="nav__list clearfix"><li class="nav__item"><a href="/" alt="首页" title="首页">首页</a></li><li class="nav__item"><a href="/archives" alt="归档" title="归档">归档</a></li><li class="nav__item"><a href="/about" alt="关于" title="关于">关于</a></li></ul></nav><button class="page__menu-btn" type="button"><i class="iconfont icon-menu"></i></button></div></nav></header><main class="page__container page__main"><div class="page__content"><article class="page__post"><div class="post__cover"><img src="/img/header.jpg" alt="Jvm内存区域和GC"></div><header class="post__info"><h1 class="post__title">Jvm内存区域和GC</h1><div class="post__mark"><div class="mark__block"><i class="mark__icon iconfont icon-write"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/">undefined</a></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-time"></i><ul class="mark__list clearfix"><li class="mark__item"><span>2018-06-06</span></li></ul></div><div class="mark__block"><i class="mark__icon iconfont icon-tab"></i><ul class="mark__list clearfix"><li class="mark__item"><a href="/tags/Java/">Java</a></li><li class="mark__item"><a href="/tags/GC/">GC</a></li><li class="mark__item"><a href="/tags/JVM/">JVM</a></li></ul></div></div></header><div class="post__content"><h1 id="Jvm内存区域和GC"><a href="#Jvm内存区域和GC" class="headerlink" title="Jvm内存区域和GC"></a>Jvm内存区域和GC</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><ul><li><strong>程序计数器</strong> 正在执行的字节码指令的地址（native方法时为undefined）</li><li><strong>Java虚拟机栈</strong> 存储栈帧（局部变量表，操作数栈，动态链接，方法出口）OOM，StackOverflowError</li><li><strong>本地方法栈</strong> 与虚拟机栈类似，是native方法的栈</li></ul><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><ul><li><p><strong>Java堆</strong> 存放对象和数组 OOM</p><ul><li><p><strong>新生带</strong></p><ul><li><strong>Eden</strong><ul><li><strong>Survivor</strong> * 2</li></ul></li></ul><ul><li><strong>老年代</strong></li></ul></li></ul></li><li><p><strong>方法区</strong>（永久代）存储已被虚拟机加载的类信息、常量、静态变量 OOM</p></li><li><strong>运行时常量池</strong> 方法区的一部分，编译器生成的字面量和符号引用 OOM</li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>不是运行时数据区的一部分，但是也会产生OOM。</p><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><h3 id="垃圾检测"><a href="#垃圾检测" class="headerlink" title="垃圾检测"></a>垃圾检测</h3><ul><li><strong>引用计数</strong> 实现简单且高效，但有循环引用的问题， 目前没有虚拟机的实现采用这个算法</li><li><strong>可达性分析</strong> 从GC Roots（虚拟机栈、方法区静态属性、方法区常量、本地方法栈）开始，沿引用链向下搜索，没被引用链连接的对象就是无用对象</li></ul><h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><ul><li><strong>强引用</strong> 代码中普遍存在的引用，只要强引用存在，被引用的对象就不会被回收</li><li><strong>软引用</strong> <code>SoftReference</code>，用来描述有用但并非必须的引用，如果一次GC之后内存仍然不足，会把这些对象列入回收范围进行第二次回收</li><li><strong>弱引用</strong> <code>WeakReference</code>，下次GC必定会被回收</li><li><strong>虚引用</strong> <code>PhantomReference</code>，不会对对象的生存时间产生影响，也无法通过虚引用取得对象实例，用于在对象被回收时收到一个通知</li></ul><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>判断常量池中的对象是否需要回收与对象相似。</p><p>无用类的条件：</p><ul><li><p>该类的所有实例都被回收</p></li><li><p>加载该类的类加载器已被回收</p></li><li><p>对应的Class对象没在任何地方被引用</p></li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li><p>标记-清除</p><ul><li>标记需要回收的对象，再统一回收</li><li>效率不高，内存碎片</li></ul></li><li><p>复制</p><ul><li>将内存分为两块，将存活的对象复制到to空间，将from空间统一清除</li><li>实现简单，运行高效，内存利用率低，存活率较高时复制效率低</li><li>新生代分为一个Eden和两个Survivor，默认大小比为8:1，每次只使用一个Survivor，GC时将新生代存活对象放到未使用的Survivor，放不下的晋升老年代（分配担保）</li></ul></li><li><p>标记-整理</p><ul><li>标记后将存活对象朝一边移动，清理掉端边界外的内存</li></ul></li></ul><h4 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h4><p>根据对象存活周期的不同，将内存划分为几块。新生代使用复制算法，老年代使用标记整理</p><h3 id="Stop-The-World"><a href="#Stop-The-World" class="headerlink" title="Stop The World"></a>Stop The World</h3><p>可达性分析必须在一个能确保一致性的快照中进行，因此在GC进行时需要停止用户线程。</p><h4 id="安全点和安全区域"><a href="#安全点和安全区域" class="headerlink" title="安全点和安全区域"></a>安全点和安全区域</h4><p>可达性分析的耗时较久（方法区就可能有几百兆），因此使用了一组OopMap的数据结构，来存储特定位置上对象内什么偏离量上是什么类型的数据，这样在GC扫描时就可以直接获得这些信息。</p><p>但是会使OopMap内容变化的指令很多，如果每条指令都生成对应的OopMap，空间成本会非常高，因此只记录了特定位置的信息，这些位置就称为安全点，线程只有到达安全点才能暂停。</p><p>具有方法调用、循环跳转、异常跳转功能的指令才会产生安全点。</p><ul><li>抢先式中断（几乎没有虚拟机实现使用） GC发生时，中断所有线程，如果有线程不在安全点，恢复线程，让它跑到安全点</li><li>主动式中断 不直接操作线程，而是在安全点检查中断标志，判断是否需要暂停</li></ul><p>安全区域是安全点的扩展，引用关系不会变化的一段代码片段。线程进入安全区域时，标示自己进入了安全区域，要离开时则检查根节点枚举或整个GC过程是否完成，没有则等待到收到可以离开安全区的信号。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><ul><li><p>Serial</p><ul><li>新生代单线程收集器</li><li>垃圾回收时只有GC线程在工作</li></ul></li><li><p>ParNew</p><ul><li>Serial的多线程版本，</li><li>垃圾回收时只有多个GC线程在工作</li></ul></li><li><p>Parallel Scavenge</p><ul><li>新生代收集器，</li><li>并行的多线程收集器，</li><li>可控制的吞吐量（吞吐量优先）</li></ul></li><li><p>Serial Old</p><ul><li>Serial的老年代版本</li></ul></li><li><p>Parallel Old</p><ul><li>Parallel Scavenge的老年代版本</li></ul></li><li><p>CMS</p><ul><li>老年代收集器，</li><li>使用标记清除算法，</li><li>追求最短回收停顿时间，</li><li>只在初始标记阶段（只记录GC Roots能关联到的对象）和重新标记阶段（修正并发标记时发生的引用变化，多线程）会STW，</li><li>对CPU资源敏感，并发时占用一定资源，程序变慢，吞吐量变低</li><li>无法清理浮动垃圾，需要预留一定空间在并发收集时供用户线程使用，如果预留空间不够，会临时启用Serial Old重新进行收集</li><li>内存碎片，找不到足够大的连续内存时，提前触发一次Full GC，可以设置在要进行Full GC，进行一次随便整理（或每几次不压缩的Full GC，整理一次碎片）。</li></ul></li><li><p>G1</p><ul><li>新生代和老年代收集器，面向服务端应用的垃圾收集器</li><li>并行并发、分代收集、空间整合、可预测停顿</li><li>将堆分为多个大小相等的独立区域，新老生代不再物理隔离，</li><li>有计划的避免在整个堆做垃圾回收，优先回收价值最大的区域</li><li>追求低停顿可尝试，追求吞吐量无优势</li></ul></li></ul><h2 id="分配和回收策略"><a href="#分配和回收策略" class="headerlink" title="分配和回收策略"></a>分配和回收策略</h2><ul><li>对象优先在Eden分配</li><li>大对象直接进入老年代 避免在Eden和Survivor中复制大量内存</li><li>长期存活对象进入老年代 每经历一次GC，对象的年龄+1，达到一定岁数就晋升老年代</li><li>动态对象年龄判断 Survivor中，相同年龄的所有对象大小总大于Survivor的一半，年龄大于等于该年龄的对象晋升老年代</li><li>空间分配担保 Survivor空间不足，晋升老年代，有老年代空间不足风险；老年代连续空间小于新生代对象总大小或历次晋升平均大小就会进行Full GC</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>忘掉这个方法</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《深入理解Java虚拟机》第2版</p><p>《Java虚拟机规范》Java SE 8版</p><div class="post-announce">感谢您的阅读，本文由 <a href="http://blog.fangjunhao.com">渣博客</a> 版权所有。如若转载，请注明出处：渣博客（<a href="http://blog.fangjunhao.com/2018/06/06/Jvm内存区域和GC/">http://blog.fangjunhao.com/2018/06/06/Jvm内存区域和GC/</a>）</div><div class="post__prevs"><div class="post__prev"><a href="/2018/05/26/装饰模式和Java-IO/" title="装饰模式和Java IO"><i class="iconfont icon-prev"></i>装饰模式和Java IO</a></div><div class="post__prev post__prev--right"></div></div></div></article></div><aside class="page__sidebar"><form id="page-search-from" class="page__search-from" action="/search/"><label class="search-form__item"><input class="input" type="text" name="search" placeholder="Search..."> <i class="iconfont icon-search"></i></label></form><div class="sidebar__block"><h3 class="block__title">简介</h3><p class="block__text">一个学渣的渣博客</p></div><div class="sidebar__block"><h3 class="block__title">文章分类</h3></div><div class="sidebar__block"><h3 class="block__title">最新文章</h3><ul class="block-list latest-post-list"><li class="latest-post-item"><a href="/2018/06/06/Jvm内存区域和GC/" title="Jvm内存区域和GC"><div class="item__cover"><img src="/img/header.jpg" alt="Jvm内存区域和GC"></div><div class="item__info"><h3 class="item__title">Jvm内存区域和GC</h3><span class="item__text">2018-06-06</span></div></a></li><li class="latest-post-item"><a href="/2018/05/26/装饰模式和Java-IO/" title="装饰模式和Java IO"><div class="item__cover"><img src="/img/header.jpg" alt="装饰模式和Java IO"></div><div class="item__info"><h3 class="item__title">装饰模式和Java IO</h3><span class="item__text">2018-05-26</span></div></a></li><li class="latest-post-item"><a href="/2018/05/25/使用Retrofit2调用HTTP-API/" title="使用Retrofit2调用HTTP API"><div class="item__cover"><img src="/img/header.jpg" alt="使用Retrofit2调用HTTP API"></div><div class="item__info"><h3 class="item__title">使用Retrofit2调用HTTP API</h3><span class="item__text">2018-05-25</span></div></a></li><li class="latest-post-item"><a href="/2018/05/25/WebSphere部署Spring-Boot/" title="WebSphere部署Spring Boot"><div class="item__cover"><img src="/img/header.jpg" alt="WebSphere部署Spring Boot"></div><div class="item__info"><h3 class="item__title">WebSphere部署Spring Boot</h3><span class="item__text">2018-05-25</span></div></a></li></ul></div><div class="sidebar__block"><h3 class="block__title">文章标签</h3><ul class="block-list tag-list clearfix"><li class="tag-item"><a class="tag-link" href="/tags/GC/">GC</a></li><li class="tag-item"><a class="tag-link" href="/tags/Hibernate/">Hibernate</a></li><li class="tag-item"><a class="tag-link" href="/tags/JVM/">JVM</a></li><li class="tag-item"><a class="tag-link" href="/tags/Java/">Java</a></li><li class="tag-item"><a class="tag-link" href="/tags/JavaScript/">JavaScript</a></li><li class="tag-item"><a class="tag-link" href="/tags/LintCode/">LintCode</a></li><li class="tag-item"><a class="tag-link" href="/tags/websocket/">websocket</a></li><li class="tag-item"><a class="tag-link" href="/tags/买卖股票的最佳时机/">买卖股票的最佳时机</a></li><li class="tag-item"><a class="tag-link" href="/tags/常用的代码/">常用的代码</a></li></ul></div></aside></main><footer class="page__footer"><section class="footer__top"><div class="page__container footer__container"><div class="footer-top__item footer-top__item--2"><h3 class="item__title">关于</h3><div class="item__content"><p class="item__text">本站是基于 Hexo 搭建的静态资源博客，欢迎点击右下角订阅 rss。</p><ul class="footer__contact-info"><li class="contact-info__item"><i class="iconfont icon-address"></i> <span>Hangzhou, Zhejiang Province, China</span></li><li class="contact-info__item"><i class="iconfont icon-email2"></i> <span>fangjunhao1994@gmail.com</span></li></ul></div></div></div></section><section class="footer__bottom"><div class="page__container footer__container"><p class="footer__copyright">© <a href="https://github.com/Mrminfive/hexo-theme-skapp" target="_blank">Skapp</a> 2017 powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, made by <a href="https://github.com/Mrminfive" target="_blank">minfive</a>.</p><ul class="footer__social-network clearfix"></ul></div></section></footer><div id="back-top" class="back-top back-top--hidden js-hidden"><i class="iconfont icon-top"></i></div></div><script src="/js/common.js"></script><script src="/js/page/post.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></body></html>